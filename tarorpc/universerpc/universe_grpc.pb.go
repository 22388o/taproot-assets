// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package universerpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UniverseClient is the client API for Universe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UniverseClient interface {
	// tarocli: `universe roots`
	//AssetRoots queries for the known Universe roots associated with each known
	//asset. These roots represent the supply/audit state for each known asset.
	AssetRoots(ctx context.Context, in *AssetRootRequest, opts ...grpc.CallOption) (*AssetRootResponse, error)
	// tarocli: `universe roots`
	//QueryAssetRoots attempts to locate the current Universe root for a specific
	//asset. This asset can be identified by its asset ID or group key.
	QueryAssetRoots(ctx context.Context, in *AssetRootQuery, opts ...grpc.CallOption) (*QueryRootResponse, error)
	// tarocli: `universe keys`
	//AssetLeafKeys queries for the set of Universe keys associated with a given
	//asset_id or group_key. Each key takes the form: (outpoint, script_key),
	//where outpoint is an outpoint in the Bitcoin blockcahin that anchors a
	//valid Taro asset commitment, and script_key is the script_key of the asset
	//within the Taro asset commitment for the given asset_id or group_key.
	AssetLeafKeys(ctx context.Context, in *ID, opts ...grpc.CallOption) (*AssetLeafKeyResponse, error)
	// tarocli: `universe leaves`
	//AssetLeaves queries for the set of asset leaves (the values in the Universe
	//MS-SMT tree) for a given asset_id or group_key. These represents either
	//asset issuance events (they have a genesis witness) or asset transfers that
	//took place on chain. The leaves contain a normal Taro asset proof, as well
	//as details for the asset.
	AssetLeaves(ctx context.Context, in *ID, opts ...grpc.CallOption) (*AssetLeafResponse, error)
	// tarocli: `universe proofs query`
	//QueryIssuanceProof attempts to query for an issuance proof for a given
	//asset based on its UniverseKey. A UniverseKey is composed of the Universe ID
	//(asset_id/group_key) and also a leaf key (outpoint || script_key). If
	//found, then the issuance proof is returned that includes an inclusion proof
	//to the known Universe root, as well as a Taro state transition or issuance
	//proof for the said asset.
	QueryIssuanceProof(ctx context.Context, in *UniverseKey, opts ...grpc.CallOption) (*IssuanceProofResponse, error)
	// tarocli: `universe proofs insert`
	//InsertIssuanceProof attempts to insert a new issuance proof into the
	//Universe tree specified by the UniverseKey. If valid, then the proof is
	//inserted into the database, with a new Universe root returned for the
	//updated asset_id/group_key.
	InsertIssuanceProof(ctx context.Context, in *IssuanceProof, opts ...grpc.CallOption) (*IssuanceProofResponse, error)
	// tarocli: `universe sync`
	//SyncUniverse takes host information for a remote Universe server, then
	//attempts to synchronize either only the set of specified asset_ids, or all
	//assets if none are specified. The sync process will attempt to query for
	//the latest known root for each asset, performing tree based reconciliation
	//to arrive at a new shared root.
	SyncUniverse(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error)
}

type universeClient struct {
	cc grpc.ClientConnInterface
}

func NewUniverseClient(cc grpc.ClientConnInterface) UniverseClient {
	return &universeClient{cc}
}

func (c *universeClient) AssetRoots(ctx context.Context, in *AssetRootRequest, opts ...grpc.CallOption) (*AssetRootResponse, error) {
	out := new(AssetRootResponse)
	err := c.cc.Invoke(ctx, "/universerpc.Universe/AssetRoots", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) QueryAssetRoots(ctx context.Context, in *AssetRootQuery, opts ...grpc.CallOption) (*QueryRootResponse, error) {
	out := new(QueryRootResponse)
	err := c.cc.Invoke(ctx, "/universerpc.Universe/QueryAssetRoots", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) AssetLeafKeys(ctx context.Context, in *ID, opts ...grpc.CallOption) (*AssetLeafKeyResponse, error) {
	out := new(AssetLeafKeyResponse)
	err := c.cc.Invoke(ctx, "/universerpc.Universe/AssetLeafKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) AssetLeaves(ctx context.Context, in *ID, opts ...grpc.CallOption) (*AssetLeafResponse, error) {
	out := new(AssetLeafResponse)
	err := c.cc.Invoke(ctx, "/universerpc.Universe/AssetLeaves", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) QueryIssuanceProof(ctx context.Context, in *UniverseKey, opts ...grpc.CallOption) (*IssuanceProofResponse, error) {
	out := new(IssuanceProofResponse)
	err := c.cc.Invoke(ctx, "/universerpc.Universe/QueryIssuanceProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) InsertIssuanceProof(ctx context.Context, in *IssuanceProof, opts ...grpc.CallOption) (*IssuanceProofResponse, error) {
	out := new(IssuanceProofResponse)
	err := c.cc.Invoke(ctx, "/universerpc.Universe/InsertIssuanceProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *universeClient) SyncUniverse(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error) {
	out := new(SyncResponse)
	err := c.cc.Invoke(ctx, "/universerpc.Universe/SyncUniverse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UniverseServer is the server API for Universe service.
// All implementations must embed UnimplementedUniverseServer
// for forward compatibility
type UniverseServer interface {
	// tarocli: `universe roots`
	//AssetRoots queries for the known Universe roots associated with each known
	//asset. These roots represent the supply/audit state for each known asset.
	AssetRoots(context.Context, *AssetRootRequest) (*AssetRootResponse, error)
	// tarocli: `universe roots`
	//QueryAssetRoots attempts to locate the current Universe root for a specific
	//asset. This asset can be identified by its asset ID or group key.
	QueryAssetRoots(context.Context, *AssetRootQuery) (*QueryRootResponse, error)
	// tarocli: `universe keys`
	//AssetLeafKeys queries for the set of Universe keys associated with a given
	//asset_id or group_key. Each key takes the form: (outpoint, script_key),
	//where outpoint is an outpoint in the Bitcoin blockcahin that anchors a
	//valid Taro asset commitment, and script_key is the script_key of the asset
	//within the Taro asset commitment for the given asset_id or group_key.
	AssetLeafKeys(context.Context, *ID) (*AssetLeafKeyResponse, error)
	// tarocli: `universe leaves`
	//AssetLeaves queries for the set of asset leaves (the values in the Universe
	//MS-SMT tree) for a given asset_id or group_key. These represents either
	//asset issuance events (they have a genesis witness) or asset transfers that
	//took place on chain. The leaves contain a normal Taro asset proof, as well
	//as details for the asset.
	AssetLeaves(context.Context, *ID) (*AssetLeafResponse, error)
	// tarocli: `universe proofs query`
	//QueryIssuanceProof attempts to query for an issuance proof for a given
	//asset based on its UniverseKey. A UniverseKey is composed of the Universe ID
	//(asset_id/group_key) and also a leaf key (outpoint || script_key). If
	//found, then the issuance proof is returned that includes an inclusion proof
	//to the known Universe root, as well as a Taro state transition or issuance
	//proof for the said asset.
	QueryIssuanceProof(context.Context, *UniverseKey) (*IssuanceProofResponse, error)
	// tarocli: `universe proofs insert`
	//InsertIssuanceProof attempts to insert a new issuance proof into the
	//Universe tree specified by the UniverseKey. If valid, then the proof is
	//inserted into the database, with a new Universe root returned for the
	//updated asset_id/group_key.
	InsertIssuanceProof(context.Context, *IssuanceProof) (*IssuanceProofResponse, error)
	// tarocli: `universe sync`
	//SyncUniverse takes host information for a remote Universe server, then
	//attempts to synchronize either only the set of specified asset_ids, or all
	//assets if none are specified. The sync process will attempt to query for
	//the latest known root for each asset, performing tree based reconciliation
	//to arrive at a new shared root.
	SyncUniverse(context.Context, *SyncRequest) (*SyncResponse, error)
	mustEmbedUnimplementedUniverseServer()
}

// UnimplementedUniverseServer must be embedded to have forward compatible implementations.
type UnimplementedUniverseServer struct {
}

func (UnimplementedUniverseServer) AssetRoots(context.Context, *AssetRootRequest) (*AssetRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssetRoots not implemented")
}
func (UnimplementedUniverseServer) QueryAssetRoots(context.Context, *AssetRootQuery) (*QueryRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAssetRoots not implemented")
}
func (UnimplementedUniverseServer) AssetLeafKeys(context.Context, *ID) (*AssetLeafKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssetLeafKeys not implemented")
}
func (UnimplementedUniverseServer) AssetLeaves(context.Context, *ID) (*AssetLeafResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssetLeaves not implemented")
}
func (UnimplementedUniverseServer) QueryIssuanceProof(context.Context, *UniverseKey) (*IssuanceProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryIssuanceProof not implemented")
}
func (UnimplementedUniverseServer) InsertIssuanceProof(context.Context, *IssuanceProof) (*IssuanceProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertIssuanceProof not implemented")
}
func (UnimplementedUniverseServer) SyncUniverse(context.Context, *SyncRequest) (*SyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncUniverse not implemented")
}
func (UnimplementedUniverseServer) mustEmbedUnimplementedUniverseServer() {}

// UnsafeUniverseServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UniverseServer will
// result in compilation errors.
type UnsafeUniverseServer interface {
	mustEmbedUnimplementedUniverseServer()
}

func RegisterUniverseServer(s grpc.ServiceRegistrar, srv UniverseServer) {
	s.RegisterService(&Universe_ServiceDesc, srv)
}

func _Universe_AssetRoots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).AssetRoots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/universerpc.Universe/AssetRoots",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).AssetRoots(ctx, req.(*AssetRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_QueryAssetRoots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetRootQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).QueryAssetRoots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/universerpc.Universe/QueryAssetRoots",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).QueryAssetRoots(ctx, req.(*AssetRootQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_AssetLeafKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).AssetLeafKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/universerpc.Universe/AssetLeafKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).AssetLeafKeys(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_AssetLeaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).AssetLeaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/universerpc.Universe/AssetLeaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).AssetLeaves(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_QueryIssuanceProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UniverseKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).QueryIssuanceProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/universerpc.Universe/QueryIssuanceProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).QueryIssuanceProof(ctx, req.(*UniverseKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_InsertIssuanceProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IssuanceProof)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).InsertIssuanceProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/universerpc.Universe/InsertIssuanceProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).InsertIssuanceProof(ctx, req.(*IssuanceProof))
	}
	return interceptor(ctx, in, info, handler)
}

func _Universe_SyncUniverse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UniverseServer).SyncUniverse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/universerpc.Universe/SyncUniverse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UniverseServer).SyncUniverse(ctx, req.(*SyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Universe_ServiceDesc is the grpc.ServiceDesc for Universe service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Universe_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "universerpc.Universe",
	HandlerType: (*UniverseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AssetRoots",
			Handler:    _Universe_AssetRoots_Handler,
		},
		{
			MethodName: "QueryAssetRoots",
			Handler:    _Universe_QueryAssetRoots_Handler,
		},
		{
			MethodName: "AssetLeafKeys",
			Handler:    _Universe_AssetLeafKeys_Handler,
		},
		{
			MethodName: "AssetLeaves",
			Handler:    _Universe_AssetLeaves_Handler,
		},
		{
			MethodName: "QueryIssuanceProof",
			Handler:    _Universe_QueryIssuanceProof_Handler,
		},
		{
			MethodName: "InsertIssuanceProof",
			Handler:    _Universe_InsertIssuanceProof_Handler,
		},
		{
			MethodName: "SyncUniverse",
			Handler:    _Universe_SyncUniverse_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "universerpc/universe.proto",
}
