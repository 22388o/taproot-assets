// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: transfers.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const applyPendingOutput = `-- name: ApplyPendingOutput :one
WITH spent_asset AS (
    SELECT genesis_id, version, asset_group_sig_id, script_version, lock_time,
           relative_lock_time
    FROM assets
    WHERE assets.asset_id = $6
)
INSERT INTO assets (
    genesis_id, version, asset_group_sig_id, script_version, lock_time,
    relative_lock_time, script_key_id, anchor_utxo_id, amount,
    split_commitment_root_hash, split_commitment_root_value
) VALUES (
    (SELECT genesis_id FROM spent_asset),
    (SELECT version FROM spent_asset),
    (SELECT asset_group_sig_id FROM spent_asset),
    (SELECT script_version FROM spent_asset),
    (SELECT lock_time FROM spent_asset),
    (SELECT relative_lock_time FROM spent_asset),
    $1, $2, $3, $4,
    $5
)
RETURNING asset_id
`

type ApplyPendingOutputParams struct {
	ScriptKeyID              int32
	AnchorUtxoID             sql.NullInt32
	Amount                   int64
	SplitCommitmentRootHash  []byte
	SplitCommitmentRootValue sql.NullInt64
	SpentAssetID             int32
}

func (q *Queries) ApplyPendingOutput(ctx context.Context, arg ApplyPendingOutputParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, applyPendingOutput,
		arg.ScriptKeyID,
		arg.AnchorUtxoID,
		arg.Amount,
		arg.SplitCommitmentRootHash,
		arg.SplitCommitmentRootValue,
		arg.SpentAssetID,
	)
	var asset_id int32
	err := row.Scan(&asset_id)
	return asset_id, err
}

const applySpendDelta = `-- name: ApplySpendDelta :one
WITH old_script_key_id AS (
    SELECT script_key_id
    FROM script_keys
    WHERE tweaked_script_key = $5
)
UPDATE assets
SET amount = $1, script_key_id = $2, 
    split_commitment_root_hash = $3,
    split_commitment_root_value = $4
WHERE script_key_id in (SELECT script_key_id FROM old_script_key_id)
RETURNING asset_id
`

type ApplySpendDeltaParams struct {
	NewAmount                int64
	NewScriptKeyID           int32
	SplitCommitmentRootHash  []byte
	SplitCommitmentRootValue sql.NullInt64
	OldScriptKey             []byte
}

func (q *Queries) ApplySpendDelta(ctx context.Context, arg ApplySpendDeltaParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, applySpendDelta,
		arg.NewAmount,
		arg.NewScriptKeyID,
		arg.SplitCommitmentRootHash,
		arg.SplitCommitmentRootValue,
		arg.OldScriptKey,
	)
	var asset_id int32
	err := row.Scan(&asset_id)
	return asset_id, err
}

const deleteAssetWitnesses = `-- name: DeleteAssetWitnesses :exec
DELETE FROM asset_witnesses
WHERE asset_id = $1
`

func (q *Queries) DeleteAssetWitnesses(ctx context.Context, assetID int32) error {
	_, err := q.db.ExecContext(ctx, deleteAssetWitnesses, assetID)
	return err
}

const deletePendingPassiveAsset = `-- name: DeletePendingPassiveAsset :exec
DELETE FROM pending_passive_asset
WHERE prev_outpoint = $1
`

func (q *Queries) DeletePendingPassiveAsset(ctx context.Context, prevOutpoint []byte) error {
	_, err := q.db.ExecContext(ctx, deletePendingPassiveAsset, prevOutpoint)
	return err
}

const deleteSpendProofs = `-- name: DeleteSpendProofs :exec
DELETE FROM transfer_proofs
WHERE transfer_id = $1
`

func (q *Queries) DeleteSpendProofs(ctx context.Context, transferID int32) error {
	_, err := q.db.ExecContext(ctx, deleteSpendProofs, transferID)
	return err
}

const fetchAssetDeltas = `-- name: FetchAssetDeltas :many
SELECT  
    deltas.old_script_key, deltas.new_amt, 
    script_keys.tweaked_script_key AS new_script_key_bytes,
    script_keys.tweak AS script_key_tweak,
    deltas.new_script_key AS new_script_key_id, 
    internal_keys.raw_key AS new_raw_script_key_bytes,
    internal_keys.key_family AS new_script_key_family, 
    internal_keys.key_index AS new_script_key_index,
    deltas.serialized_witnesses, split_commitment_root_hash, 
    split_commitment_root_value
FROM asset_deltas deltas
JOIN script_keys
    ON deltas.new_script_key = script_keys.script_key_id
JOIN internal_keys 
    ON script_keys.internal_key_id = internal_keys.key_id
WHERE transfer_id = $1
`

type FetchAssetDeltasRow struct {
	OldScriptKey             []byte
	NewAmt                   int64
	NewScriptKeyBytes        []byte
	ScriptKeyTweak           []byte
	NewScriptKeyID           int32
	NewRawScriptKeyBytes     []byte
	NewScriptKeyFamily       int32
	NewScriptKeyIndex        int32
	SerializedWitnesses      []byte
	SplitCommitmentRootHash  []byte
	SplitCommitmentRootValue sql.NullInt64
}

func (q *Queries) FetchAssetDeltas(ctx context.Context, transferID int32) ([]FetchAssetDeltasRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAssetDeltas, transferID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetDeltasRow
	for rows.Next() {
		var i FetchAssetDeltasRow
		if err := rows.Scan(
			&i.OldScriptKey,
			&i.NewAmt,
			&i.NewScriptKeyBytes,
			&i.ScriptKeyTweak,
			&i.NewScriptKeyID,
			&i.NewRawScriptKeyBytes,
			&i.NewScriptKeyFamily,
			&i.NewScriptKeyIndex,
			&i.SerializedWitnesses,
			&i.SplitCommitmentRootHash,
			&i.SplitCommitmentRootValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAssetDeltasWithProofs = `-- name: FetchAssetDeltasWithProofs :many
SELECT  
    deltas.old_script_key, deltas.new_amt, 
    script_keys.tweaked_script_key AS new_script_key_bytes,
    script_keys.tweak AS script_key_tweak,
    deltas.new_script_key AS new_script_key_id, 
    internal_keys.raw_key AS new_raw_script_key_bytes,
    internal_keys.key_family AS new_script_key_family, 
    internal_keys.key_index AS new_script_key_index,
    deltas.serialized_witnesses, deltas.split_commitment_root_hash, 
    deltas.split_commitment_root_value, transfer_proofs.sender_proof,
    transfer_proofs.receiver_proof
FROM asset_deltas deltas
JOIN script_keys
    ON deltas.new_script_key = script_keys.script_key_id
JOIN internal_keys 
    ON script_keys.internal_key_id = internal_keys.key_id
JOIN transfer_proofs
    ON deltas.proof_id = transfer_proofs.proof_id
WHERE deltas.transfer_id = $1
`

type FetchAssetDeltasWithProofsRow struct {
	OldScriptKey             []byte
	NewAmt                   int64
	NewScriptKeyBytes        []byte
	ScriptKeyTweak           []byte
	NewScriptKeyID           int32
	NewRawScriptKeyBytes     []byte
	NewScriptKeyFamily       int32
	NewScriptKeyIndex        int32
	SerializedWitnesses      []byte
	SplitCommitmentRootHash  []byte
	SplitCommitmentRootValue sql.NullInt64
	SenderProof              []byte
	ReceiverProof            []byte
}

func (q *Queries) FetchAssetDeltasWithProofs(ctx context.Context, transferID int32) ([]FetchAssetDeltasWithProofsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAssetDeltasWithProofs, transferID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAssetDeltasWithProofsRow
	for rows.Next() {
		var i FetchAssetDeltasWithProofsRow
		if err := rows.Scan(
			&i.OldScriptKey,
			&i.NewAmt,
			&i.NewScriptKeyBytes,
			&i.ScriptKeyTweak,
			&i.NewScriptKeyID,
			&i.NewRawScriptKeyBytes,
			&i.NewScriptKeyFamily,
			&i.NewScriptKeyIndex,
			&i.SerializedWitnesses,
			&i.SplitCommitmentRootHash,
			&i.SplitCommitmentRootValue,
			&i.SenderProof,
			&i.ReceiverProof,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSpendProofs = `-- name: FetchSpendProofs :one
SELECT sender_proof, receiver_proof
FROM transfer_proofs
WHERE transfer_id = $1
`

type FetchSpendProofsRow struct {
	SenderProof   []byte
	ReceiverProof []byte
}

func (q *Queries) FetchSpendProofs(ctx context.Context, transferID int32) (FetchSpendProofsRow, error) {
	row := q.db.QueryRowContext(ctx, fetchSpendProofs, transferID)
	var i FetchSpendProofsRow
	err := row.Scan(&i.SenderProof, &i.ReceiverProof)
	return i, err
}

const fetchTransferInputs = `-- name: FetchTransferInputs :many
SELECT input_id, anchor_point, asset_id, script_key, amount
FROM asset_transfer_inputs inputs
WHERE transfer_id = $1
`

type FetchTransferInputsRow struct {
	InputID     int32
	AnchorPoint []byte
	AssetID     []byte
	ScriptKey   []byte
	Amount      int64
}

func (q *Queries) FetchTransferInputs(ctx context.Context, transferID int32) ([]FetchTransferInputsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchTransferInputs, transferID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTransferInputsRow
	for rows.Next() {
		var i FetchTransferInputsRow
		if err := rows.Scan(
			&i.InputID,
			&i.AnchorPoint,
			&i.AssetID,
			&i.ScriptKey,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTransferOutputs = `-- name: FetchTransferOutputs :many
SELECT
    output_id, proof_suffix, amount, serialized_witnesses, script_key_local,
    split_commitment_root_hash, split_commitment_root_value, num_passive_assets,
    utxos.utxo_id AS anchor_utxo_id,
    utxos.outpoint AS anchor_outpoint,
    utxos.amt_sats AS anchor_value,
    utxos.taro_root AS anchor_taro_root,
    utxos.tapscript_sibling AS anchor_tapscript_sibling,
    utxo_internal_keys.raw_key AS internal_key_raw_key_bytes,
    utxo_internal_keys.key_family AS internal_key_family,
    utxo_internal_keys.key_index AS internal_key_index,
    script_keys.tweaked_script_key AS script_key_bytes,
    script_keys.tweak AS script_key_tweak,
    script_key AS script_key_id,
    script_internal_keys.raw_key AS script_key_raw_key_bytes,
    script_internal_keys.key_family AS script_key_family,
    script_internal_keys.key_index AS script_key_index
FROM asset_transfer_outputs outputs
JOIN managed_utxos utxos
  ON outputs.anchor_utxo = utxos.utxo_id
JOIN script_keys
  ON outputs.script_key = script_keys.script_key_id
JOIN internal_keys script_internal_keys
  ON script_keys.internal_key_id = script_internal_keys.key_id
JOIN internal_keys utxo_internal_keys
  ON utxos.internal_key_id = utxo_internal_keys.key_id
WHERE transfer_id = $1
`

type FetchTransferOutputsRow struct {
	OutputID                 int32
	ProofSuffix              []byte
	Amount                   int64
	SerializedWitnesses      []byte
	ScriptKeyLocal           bool
	SplitCommitmentRootHash  []byte
	SplitCommitmentRootValue sql.NullInt64
	NumPassiveAssets         int32
	AnchorUtxoID             int32
	AnchorOutpoint           []byte
	AnchorValue              int64
	AnchorTaroRoot           []byte
	AnchorTapscriptSibling   []byte
	InternalKeyRawKeyBytes   []byte
	InternalKeyFamily        int32
	InternalKeyIndex         int32
	ScriptKeyBytes           []byte
	ScriptKeyTweak           []byte
	ScriptKeyID              int32
	ScriptKeyRawKeyBytes     []byte
	ScriptKeyFamily          int32
	ScriptKeyIndex           int32
}

func (q *Queries) FetchTransferOutputs(ctx context.Context, transferID int32) ([]FetchTransferOutputsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchTransferOutputs, transferID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchTransferOutputsRow
	for rows.Next() {
		var i FetchTransferOutputsRow
		if err := rows.Scan(
			&i.OutputID,
			&i.ProofSuffix,
			&i.Amount,
			&i.SerializedWitnesses,
			&i.ScriptKeyLocal,
			&i.SplitCommitmentRootHash,
			&i.SplitCommitmentRootValue,
			&i.NumPassiveAssets,
			&i.AnchorUtxoID,
			&i.AnchorOutpoint,
			&i.AnchorValue,
			&i.AnchorTaroRoot,
			&i.AnchorTapscriptSibling,
			&i.InternalKeyRawKeyBytes,
			&i.InternalKeyFamily,
			&i.InternalKeyIndex,
			&i.ScriptKeyBytes,
			&i.ScriptKeyTweak,
			&i.ScriptKeyID,
			&i.ScriptKeyRawKeyBytes,
			&i.ScriptKeyFamily,
			&i.ScriptKeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAssetDelta = `-- name: InsertAssetDelta :exec
INSERT INTO asset_deltas (
    old_script_key, new_amt, new_script_key, serialized_witnesses, transfer_id,
    proof_id, split_commitment_root_hash, split_commitment_root_value
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
`

type InsertAssetDeltaParams struct {
	OldScriptKey             []byte
	NewAmt                   int64
	NewScriptKey             int32
	SerializedWitnesses      []byte
	TransferID               int32
	ProofID                  int32
	SplitCommitmentRootHash  []byte
	SplitCommitmentRootValue sql.NullInt64
}

func (q *Queries) InsertAssetDelta(ctx context.Context, arg InsertAssetDeltaParams) error {
	_, err := q.db.ExecContext(ctx, insertAssetDelta,
		arg.OldScriptKey,
		arg.NewAmt,
		arg.NewScriptKey,
		arg.SerializedWitnesses,
		arg.TransferID,
		arg.ProofID,
		arg.SplitCommitmentRootHash,
		arg.SplitCommitmentRootValue,
	)
	return err
}

const insertAssetTransfer = `-- name: InsertAssetTransfer :one
INSERT INTO asset_transfers (
    old_anchor_point, new_internal_key, new_anchor_utxo, height_hint, transfer_time_unix
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id
`

type InsertAssetTransferParams struct {
	OldAnchorPoint   []byte
	NewInternalKey   int32
	NewAnchorUtxo    int32
	HeightHint       int32
	TransferTimeUnix time.Time
}

func (q *Queries) InsertAssetTransfer(ctx context.Context, arg InsertAssetTransferParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertAssetTransfer,
		arg.OldAnchorPoint,
		arg.NewInternalKey,
		arg.NewAnchorUtxo,
		arg.HeightHint,
		arg.TransferTimeUnix,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertAssetTransferInput = `-- name: InsertAssetTransferInput :exec
INSERT INTO asset_transfer_inputs (
    transfer_id, anchor_point, asset_id, script_key, amount
) VALUES (
    $1, $2, $3, $4, $5
)
`

type InsertAssetTransferInputParams struct {
	TransferID  int32
	AnchorPoint []byte
	AssetID     []byte
	ScriptKey   []byte
	Amount      int64
}

func (q *Queries) InsertAssetTransferInput(ctx context.Context, arg InsertAssetTransferInputParams) error {
	_, err := q.db.ExecContext(ctx, insertAssetTransferInput,
		arg.TransferID,
		arg.AnchorPoint,
		arg.AssetID,
		arg.ScriptKey,
		arg.Amount,
	)
	return err
}

const insertAssetTransferOutput = `-- name: InsertAssetTransferOutput :exec
INSERT INTO asset_transfer_outputs (
    transfer_id, anchor_utxo, script_key, script_key_local,
    amount, serialized_witnesses, split_commitment_root_hash,
    split_commitment_root_value, proof_suffix, num_passive_assets
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
`

type InsertAssetTransferOutputParams struct {
	TransferID               int32
	AnchorUtxo               int32
	ScriptKey                int32
	ScriptKeyLocal           bool
	Amount                   int64
	SerializedWitnesses      []byte
	SplitCommitmentRootHash  []byte
	SplitCommitmentRootValue sql.NullInt64
	ProofSuffix              []byte
	NumPassiveAssets         int32
}

func (q *Queries) InsertAssetTransferOutput(ctx context.Context, arg InsertAssetTransferOutputParams) error {
	_, err := q.db.ExecContext(ctx, insertAssetTransferOutput,
		arg.TransferID,
		arg.AnchorUtxo,
		arg.ScriptKey,
		arg.ScriptKeyLocal,
		arg.Amount,
		arg.SerializedWitnesses,
		arg.SplitCommitmentRootHash,
		arg.SplitCommitmentRootValue,
		arg.ProofSuffix,
		arg.NumPassiveAssets,
	)
	return err
}

const insertPendingPassiveAsset = `-- name: InsertPendingPassiveAsset :exec
WITH target_asset(asset_id) AS (
    SELECT assets.asset_id
    FROM assets
        JOIN genesis_assets
            ON assets.genesis_id = genesis_assets.gen_asset_id
        JOIN managed_utxos utxos
            ON assets.anchor_utxo_id = utxos.utxo_id
        JOIN script_keys
            ON assets.script_key_id = script_keys.script_key_id
    WHERE genesis_assets.asset_id = $5
        AND utxos.outpoint = $1
        AND script_keys.tweaked_script_key = $2
)
INSERT INTO pending_passive_asset (
    asset_id, prev_outpoint, script_key, new_witness_stack,
    new_proof
) VALUES (
    (SELECT asset_id FROM target_asset), $1,
          $2, $3, $4
)
`

type InsertPendingPassiveAssetParams struct {
	PrevOutpoint    []byte
	ScriptKey       []byte
	NewWitnessStack []byte
	NewProof        []byte
	AssetGenesisID  []byte
}

func (q *Queries) InsertPendingPassiveAsset(ctx context.Context, arg InsertPendingPassiveAssetParams) error {
	_, err := q.db.ExecContext(ctx, insertPendingPassiveAsset,
		arg.PrevOutpoint,
		arg.ScriptKey,
		arg.NewWitnessStack,
		arg.NewProof,
		arg.AssetGenesisID,
	)
	return err
}

const insertReceiverProofTransferAttempt = `-- name: InsertReceiverProofTransferAttempt :exec
INSERT INTO receiver_proof_transfer_attempts (
    proof_locator_hash, time_unix
) VALUES (
    $1, $2
)
`

type InsertReceiverProofTransferAttemptParams struct {
	ProofLocatorHash []byte
	TimeUnix         time.Time
}

func (q *Queries) InsertReceiverProofTransferAttempt(ctx context.Context, arg InsertReceiverProofTransferAttemptParams) error {
	_, err := q.db.ExecContext(ctx, insertReceiverProofTransferAttempt, arg.ProofLocatorHash, arg.TimeUnix)
	return err
}

const insertSpendProofs = `-- name: InsertSpendProofs :one
INSERT INTO transfer_proofs (
   transfer_id, sender_proof, receiver_proof 
) VALUES (
    $1, $2, $3
) RETURNING proof_id
`

type InsertSpendProofsParams struct {
	TransferID    int32
	SenderProof   []byte
	ReceiverProof []byte
}

func (q *Queries) InsertSpendProofs(ctx context.Context, arg InsertSpendProofsParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertSpendProofs, arg.TransferID, arg.SenderProof, arg.ReceiverProof)
	var proof_id int32
	err := row.Scan(&proof_id)
	return proof_id, err
}

const queryAssetTransfers = `-- name: QueryAssetTransfers :many
SELECT 
    asset_transfers.old_anchor_point, utxos.outpoint AS new_anchor_point,
    utxos.taro_root, utxos.tapscript_sibling,
    utxos.utxo_id AS new_anchor_utxo_id, txns.raw_tx AS anchor_tx_bytes,
    txns.txid AS anchor_txid, txns.txn_id AS anchor_tx_primary_key,
    txns.chain_fees, transfer_time_unix, keys.raw_key AS internal_key_bytes,
    keys.key_family AS internal_key_fam, keys.key_index AS internal_key_index,
    id AS transfer_id, height_hint, transfer_time_unix
FROM asset_transfers
JOIN internal_keys keys
    ON asset_transfers.new_internal_key = keys.key_id
JOIN managed_utxos utxos
    ON asset_transfers.new_anchor_utxo = utxos.utxo_id
JOIN chain_txns txns
    ON utxos.utxo_id = txns.txn_id
WHERE (
    -- We'll use this clause to filter out for only transfers that are
    -- unconfirmed. But only if the unconf_only field is set.
    -- TODO(roasbeef): just do the confirmed bit,
    ($1 = false OR $1 IS NULL OR
      (CASE WHEN txns.block_hash IS NULL THEN true ELSE false END) = $1)

    AND
    
    -- Here we have another optional query clause to select a given transfer
    -- based on the anchor_tx_hash, but only if it's specified.
    (txns.txid = $2 OR
       $2 IS NULL)
)
`

type QueryAssetTransfersParams struct {
	UnconfOnly   interface{}
	AnchorTxHash []byte
}

type QueryAssetTransfersRow struct {
	OldAnchorPoint     []byte
	NewAnchorPoint     []byte
	TaroRoot           []byte
	TapscriptSibling   []byte
	NewAnchorUtxoID    int32
	AnchorTxBytes      []byte
	AnchorTxid         []byte
	AnchorTxPrimaryKey int32
	ChainFees          int64
	TransferTimeUnix   time.Time
	InternalKeyBytes   []byte
	InternalKeyFam     int32
	InternalKeyIndex   int32
	TransferID         int32
	HeightHint         int32
	TransferTimeUnix_2 time.Time
}

func (q *Queries) QueryAssetTransfers(ctx context.Context, arg QueryAssetTransfersParams) ([]QueryAssetTransfersRow, error) {
	rows, err := q.db.QueryContext(ctx, queryAssetTransfers, arg.UnconfOnly, arg.AnchorTxHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryAssetTransfersRow
	for rows.Next() {
		var i QueryAssetTransfersRow
		if err := rows.Scan(
			&i.OldAnchorPoint,
			&i.NewAnchorPoint,
			&i.TaroRoot,
			&i.TapscriptSibling,
			&i.NewAnchorUtxoID,
			&i.AnchorTxBytes,
			&i.AnchorTxid,
			&i.AnchorTxPrimaryKey,
			&i.ChainFees,
			&i.TransferTimeUnix,
			&i.InternalKeyBytes,
			&i.InternalKeyFam,
			&i.InternalKeyIndex,
			&i.TransferID,
			&i.HeightHint,
			&i.TransferTimeUnix_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPendingPassiveAssets = `-- name: QueryPendingPassiveAssets :many
SELECT passive.asset_id, passive.script_key, passive.new_witness_stack,
       passive.new_proof, genesis_info_view.asset_id AS genesis_id
FROM pending_passive_asset as passive
    JOIN assets
        ON passive.asset_id = assets.asset_id
    JOIN genesis_info_view
        ON assets.genesis_id = genesis_info_view.gen_asset_id
WHERE prev_outpoint = $1
`

type QueryPendingPassiveAssetsRow struct {
	AssetID         int32
	ScriptKey       []byte
	NewWitnessStack []byte
	NewProof        []byte
	GenesisID       []byte
}

func (q *Queries) QueryPendingPassiveAssets(ctx context.Context, prevOutpoint []byte) ([]QueryPendingPassiveAssetsRow, error) {
	rows, err := q.db.QueryContext(ctx, queryPendingPassiveAssets, prevOutpoint)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryPendingPassiveAssetsRow
	for rows.Next() {
		var i QueryPendingPassiveAssetsRow
		if err := rows.Scan(
			&i.AssetID,
			&i.ScriptKey,
			&i.NewWitnessStack,
			&i.NewProof,
			&i.GenesisID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryReceiverProofTransferAttempt = `-- name: QueryReceiverProofTransferAttempt :many
SELECT time_unix
FROM receiver_proof_transfer_attempts
WHERE proof_locator_hash = $1
ORDER BY time_unix DESC
`

func (q *Queries) QueryReceiverProofTransferAttempt(ctx context.Context, proofLocatorHash []byte) ([]time.Time, error) {
	rows, err := q.db.QueryContext(ctx, queryReceiverProofTransferAttempt, proofLocatorHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []time.Time
	for rows.Next() {
		var time_unix time.Time
		if err := rows.Scan(&time_unix); err != nil {
			return nil, err
		}
		items = append(items, time_unix)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reAnchorAssets = `-- name: ReAnchorAssets :exec
WITH assets_to_update AS (
    SELECT asset_id
    FROM assets
    JOIN managed_utxos utxos
        ON assets.anchor_utxo_id = utxos.utxo_id
    WHERE utxos.outpoint = $2
)
UPDATE assets
SET anchor_utxo_id = $1
WHERE asset_id IN (SELECT asset_id FROM assets_to_update)
`

type ReAnchorAssetsParams struct {
	NewOutpointUtxoID sql.NullInt32
	OldOutpoint       []byte
}

func (q *Queries) ReAnchorAssets(ctx context.Context, arg ReAnchorAssetsParams) error {
	_, err := q.db.ExecContext(ctx, reAnchorAssets, arg.NewOutpointUtxoID, arg.OldOutpoint)
	return err
}
